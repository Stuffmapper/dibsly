(function() {
  var factories;

  factories = angular.module('factories');

  factories.factory('MarkerService', [
    '$http','LocalService','MapsService', 'Marker', '$resource', '$rootScope', '$q', '$timeout',
     function($http,LocalService, MapsService, Marker, $resource, $rootScope, $q, $timeout) {
     var self = this;
     self.markers = {}
     self.toCheck = [];

      return {
        editProperties: [
          'id',
          'category',
          'description',
          'image_url',
          'latitude',
          'longitude',
          'on_the_curb',
          'published',
          'title'
        ],
        icons: {
            standard:'<%= asset_path('salmon-pin.svg')%>',
            dibber: '<%= asset_path('yellow-pin.svg')%>',
            creator:'<%= asset_path('darkblue-pin.svg')%>',
            moving: '<%= asset_path('green-pin.svg')%>',
            giveStuff: '<%= asset_path('pin.svg')%>'
          },
        categories:[
          'Arts & Crafts',
          'Books, Games, Media',
          'Building & Garden Materials',
          'Clothing & Accessories',
          'Electronics',
          'Furniture & Household',
          'General',
          'Kids & Babies',
          'Recreation'
        ],

        clearMarkers: function( exception ){
          var promises = [];
          angular.forEach(self.markers, function(value, key) {
             if (key !== exception && value.marker ){
              MapsService.clearMapMarker(value.marker)
             } else if (value.marker){  promises.push(MapsService.setMapMarker(value.marker)) }
          });
          return $q.all(promises);
        },
        clearWindows: function(exception, map){
          angular.forEach(self.markers, function(value, key) {
            if (String(key) !== String(exception)) {
              if (value.infowindow && value.marker) {
                return MapsService.closeInfoWindow(value.infowindow, value.marker);
              }
            } else {
              return MapsService.openInfoWindow(value.infowindow, value.marker);
            }
          });
        },

        contains: function(object, attributes){
          var contains = false;
          angular.forEach(attributes, function(attribute){
            angular.forEach(attribute, function(value, attr){
              if(object.hasOwnProperty(attr) && object[attr] === value){
               contains = true;
              }
            });
          });
          return contains;

        },
        delete: function(id){
          //REVIEW is this being used anywhere?
          var marker = self.markers[id];
          if(marker){
            MapsService.clearMapMarker(marker.marker);
            marker.deleteLocal();
            delete self.markers[id];
          } else { console.warn("marker not found %s not deleted", id)}
        },
        expireMarkers: function(){
          //sets a timeout, should be called only once
          //NO TEST IN PLACE
          var that = this;
          $timeout(function(){
            if(!self.updating){
              var time = Date.now();
              self.updating = true
              angular.forEach(self.markers, function(marker, key){
                if(marker.locallyUpdated  < time - 300000  ){ //BUGBUGS
                  console.log('You have an old marker')
                  var prom = marker.get()
                  .then( function(){
                    if(marker.shouldDelete()){ that.delete(marker.id) }
                    else(that.setMarker(marker) )
                  });
                  self.toCheck.push(prom);
                }
              })
              return $q.all(self.toCheck)
              .then(function(){ 
                console.log('Done checking for old makers ')
                self.toCheck = [];
                self.updating = false;
                that.expireMarkers() } );
            }  
          }, 15000);
        },
        getMarker:function(id){
          return self.markers[id];
        },
        getMarkerAsync: function(id){
          var that = this;
          var defer = $q.defer();
          var marker = self.markers[id] || new Marker({ id:id });
          marker.get()
          .then(
            function(){
              that.setMarker(marker)
              .then(function(){ defer.resolve( self.markers[id] ) }); 
            },
            function(err){ defer.reject(err) }
          );
          return defer.promise;
        },
        getSetTemporary: function(id){
        // returns a promise
          var that = this;
          var markerSet = self.markers[id];
          var marker = markerSet ? markerSet : {
            id: id,
            temporary:true,
            updated_at: Date.now(),
            icon: id,
            draggable:true 
          };
          if (!markerSet){
             return MapsService.getCenter()
            .then( function(center){
              marker.latitude = center.lat;
              marker.longitude = center.lng;
              return that.setMarker(marker);
            })
          } else { return $q.when(marker); }
        },

        isEmpty: function(obj){
          // null and undefined are "empty"
          var that = this;
          if (!obj) return true;
          if (obj.length === 1 && that.isEmpty(obj[0]) )   return true;
          if (obj.length > 0 )    return false;
          if (obj.length === 0)  return true;
          for (var key in obj) {
              if (hasOwnProperty.call(obj, key)) return false;
          }
          return true;

        },

        setAll: function(has, doesnot){
          var that = this;
          angular.forEach( that.where(has, doesnot), function(marker){
            if(marker.marker){
              MapsService.setMapMarker(marker.marker)
            }
          });
        },

        setGoogleMarker: function(marker){
          var defer = $q.defer();
          var that = this;
          if(!marker.marker ) {
            MapsService.newMapMarker({
              icon: that.icons[marker.icon] || that.icons.standard,
              draggable: marker.draggable,
              position: { lat: marker.latitude, lng: marker.longitude },
              title: marker.description
            })
            .then(function(gmarker){ 
              self.markers[marker.id].marker = gmarker;
              if (!marker.temporary){
                MapsService.addMarkerListener(gmarker, 'click', function(){
                  $rootScope.$broadcast('detailsWanted', {
                        markerId: marker.id
                  });
                });
              } else {
                MapsService.addMarkerListener(gmarker, 'dragend', function(){
                  //NOTE the standard is to keep functions specific to google
                  //in the mapservice. Using MapsService.getPosition seems
                  // to cause issues 
                  marker.latitude = gmarker.getPosition().lat();
                  marker.longitude = gmarker.getPosition().lng();
                });
               }
              defer.resolve(marker);
            })
          } else { 
            //needs to update lat lng
            MapsService.updateMarker(marker);
            //pretty important
            defer.resolve(marker) }
          return defer.promise; 
        },

        setMarker: function(marker){
          var that = this;
          marker.updated_at = new Date(marker.updated_at);
          marker.locallyUpdated = Date.now();
          if(!self.markers[marker.id]){
            self.markers[marker.id] = new Marker(marker);
          } else { angular.extend(self.markers[marker.id], marker ) }
          self.markers[marker.id].saveLocal()
          return that.setGoogleMarker(self.markers[marker.id]);
        },

        updateWindow: function(id) {
          var infowindow, innerContent, marker;
          marker = self.markers[id];
          innerContent = "<div > <div id='siteNotice' class='stuff-map-image'></div> <img src=" +
           marker.image_url + " width='200px' ></img> <div id='bodyContent'> <p>" +
           marker.description + "</p> </div> </div> </div>";
          if (!marker.description) {
            marker.description = "";
          }
          if (!marker.infowindow) {
            infowindow = MapsService.newInfoWindow({
              content: innerContent
            });
            return marker.infowindow = infowindow;
          } else {
            return MapsService.setInfoContent(marker, innerContent);
          }
        },


        where: function(has, doesnot){
          var that = this;
          if (has && has.constructor  !== Array){
            var has = [has];
          }
          var results = [];
          angular.forEach(self.markers,
            function(value ){
              if(that.contains(value,has) && !that.contains(value, doesnot)){
                results.push(value)
              } else if ( !that.contains(value, doesnot) && that.isEmpty(has) ) {  //TOFIX
                results.push(value);
              }
            }
          );
          results.sort(function (a, b) {
            return (a['updated_at'] < b['updated_at'] ? 1 : -1);

          });
          return results;
        }
      };
    }
  ]);

}).call(this);
