metric_fu shift the first line
================================================================================
 ./app/controllers/application_controller.rb
================================================================================
   class ApplicationController < ActionController::Base
--   # Prevent CSRF attacks by raising an exception.
--   # For APIs, you may want to use :null_session instead.
     protect_from_forgery with: :exception
     helper_method :current_user
-- 
     private
-- 
     def current_user
       @current_user ||= User.find(session[:user_id]) if session[:user_id]
--   end
-- 
-- end
-- 
--  
-- 

================================================================================
 ./app/controllers/posts_controller.rb
================================================================================
   class PostsController < ApplicationController
--  
     before_action :set_post, only: [:show, :claim]
--         #this should be part of the model _ on save
-- 
--   # GET /posts
--   # GET /posts.json
-- 
     def index
       user_ip = request.location
--     
       if !user_ip.longitude == 0.0
!!       @map = user_ip.longitude.to_s + ', ' + user_ip.latitude.to_s
--     else
         @map = '47.6097,-122.3331'
--     end
--   end
-- 
--   # POST /posts
--   # POST /posts.json
     def create
!!     if (current_user)
!!       cleaned_params = post_params.delete_if{
!!           |key, value| value == 'undefined'  
--       }
!!       @user = User.find( current_user.id )
!!       @post = Post.new(cleaned_params.merge(
--           :ip => request.remote_ip, 
--           :status => 'new', 
--           :creator_id => @user.id ))
-- 
!!       if @post.save
!!         @post.save
!!         render json: '[]', status: :ok
--       else
!!         render json: @post.errors, status: :unprocessable_entity
--       end
--     else
!!       render json: {error: 'not authorized '}, status: :unauthorized
--     end
--   end
-- 
--   # POST /posts/dib/1
--   # POST /posts/dib/1.json
     def dib
!!     if current_user && dib_params[:id] 
-- 
!!       @post = Post.find(dib_params[:id])
--     
!!       if @post.available_to_dib?
!!          @post.create_new_dib(current_user)
!!          add_dib(@post, request, current_user)
!!          render json: '[]', status: :ok 
--       end
--     else
!!       render json: '[]', status: :unprocessable_entity
--     end
--   end
-- 
--   # POST /posts/claim/1
--   # POST /posts/claim/1.json
-- 
     def geolocated 
       @posts = Post.where(:latitude => params[:swLat]..params[:neLat])
--                  .where(:longitude => params[:swLng]..params[:neLng])
       render json: @posts
--   end
-- 
--   # POST /posts/grid_mode.json
     def grid_mode
!!     session[:grid_mode] = params[:grid_mode]
!!     if (current_user)
!!       current_user.grid_mode = session[:grid_mode]
!!       current_user.save
--     end
!!     respond_to do |format|
!!         format.json {render json: '[]', status: :ok}
--     end
--   end
-- 
--   # GET /posts/search
     def search
!!     @posts = Post.where("title ILIKE ? 
--                  AND status = ? 
--                  AND (dibbed_until IS NULL 
--                    OR (dibbed_until IS NOT NULL 
--                      AND dibbed_until <= NOW()))", 
--                  "%#{params[:term]}%",
--                  'new').page(params[:page]).per(6)
!!     @term = params[:term]
!!     if (current_user)
!!       @post = Post.new(
--           :on_the_curb => 1,
--           :phone_number => current_user.phone_number)
!!       @message = Message.new()
--     else
!!       @user = User.new
--     end
!!     render action: 'index'
--   end
-- 
--   # GET /posts/my_stuff
     def my_stuff
       if (current_user)
!!       @posts = Post.where(:creator_id => current_user.id )
!!       render json: @posts
--     else
         render json: {message: 'User not logged in' }, status: :unauthorized
--     end
--   end
-- 
-- 
     private
--     # Use callbacks to share common setup or constraints between actions.
       def set_post
!!       @post = Post.find(params[:id])
--     end
-- 
--     # Never trust parameters from the scary internet, 
--     # only allow the white list through.
       def post_params
!!       params.permit(:image,:category, :latitude, :longitude)
--     end
-- 
-- 
-- end

================================================================================
 ./app/controllers/sessions_controller.rb
================================================================================
   class SessionsController < ApplicationController
     def create
-- 
       user = User.authenticate(params[:username], params[:password])
-- 
         if user
!!         session[:user_id] = user.id
!!         session[:latitude] = user.latitude
!!         session[:longitude] = user.longitude
!!         session[:zoom] = user.zoom
!!         session[:grid_mode] = user.grid_mode
!!         render json: {user:user.username}, status: :ok
--       else
           render json: '[]', status: :unprocessable_entity
--       end
--   end
-- 
     def destroy
!!     session[:user_id] = nil
!!     session[:latitude] = nil
!!     session[:longitude] = nil
!!     session[:zoom] = nil
!!     session[:grid_mode] = nil
!!     render json: '[]', status: :ok
--   end
-- 
     def check
       if current_user
-- 
!!       render json: {
--           message: 'User is logged in',
--           user: current_user.username },
--           status: :ok
--     else
         render json: {
--           message: 'User not logged in' },
--           status: :unauthorized
--     end
--   end
-- 
     private
--     # Never trust parameters from the scary internet, 
--     # only allow the white list through.
       def sessions_params
!!       params.permit(:username, :password)
--     end
-- end
-- 

================================================================================
 ./app/helpers/application_helper.rb
================================================================================
   module ApplicationHelper
-- end

================================================================================
 ./app/helpers/dibs_controller_helper.rb
================================================================================
   module DibsControllerHelper
-- end

================================================================================
 ./app/helpers/dibs_helper.rb
================================================================================
   module DibsHelper
-- end

================================================================================
 ./app/helpers/feedbacks_helper.rb
================================================================================
   module FeedbacksHelper
-- end

================================================================================
 ./app/helpers/messages_helper.rb
================================================================================
   module MessagesHelper
-- end

================================================================================
 ./app/helpers/posts_helper.rb
================================================================================
   module PostsHelper
-- end

================================================================================
 ./app/helpers/sessions_helper.rb
================================================================================
   module SessionsHelper
-- end

================================================================================
 ./app/helpers/users_helper.rb
================================================================================
   module UsersHelper
-- end

================================================================================
 ./app/models/dib.rb
================================================================================
   class Dib < ActiveRecord::Base
     belongs_to :user, :class_name => User
     belongs_to :post, :class_name => Post
--   
     STATUSES = [STATUS_NEW = 'new', STATUS_DELETED = 'deleted', STATUS_FINISHED = 'finished']
-- 
--   # 43200 seconds = 12 hours
     @@timeSpan = 43200
     cattr_reader :timeSpan
--   
     validates_presence_of :creator_id
     validates_presence_of :post_id
     validates :status, inclusion: {in: STATUSES}
     validate :cannot_dib_own_post 
     before_validation(on: :create) do
!!     available_to_dib?
--   end
-- 
-- 
-- 
     def cannot_dib_own_post
!!     if self.creator_id == self.post.creator_id
!!       errors.add(:dib, "You can't dib your own stuff")
--     end
--   end
-- 
     def available_to_dib?
!!     if !Post.find(self.post_id).available_to_dib?
!!       errors.add(:dib, "post not available to div")
--     end
--   end
-- 
--   # to make sure we don't expose it
     def ip
!!     ''
--   end
-- end

================================================================================
 ./app/models/message.rb
================================================================================
   class Message < ActiveRecord::Base
     belongs_to :user, :class_name => User, :foreign_key => :sender_id
     belongs_to :user, :class_name => User, :foreign_key => :receiver_id
     attr_readonly :creator_id
-- 
     STATUSES = [STATUS_NEW = 'new', STATUS_DELETED = 'deleted', STATUS_READ = 'read']
-- 
     default_scope { order('created_at DESC') }
-- 
     validates_presence_of :sender_id
     validates_presence_of :receiver_id
     validates_presence_of :content
     validates :status, inclusion: {in: STATUSES}
-- 
     def send_notification(subject, text_content, html_content)
!!     @receiver = User.find(self.receiver_id)
-- 
!!     require 'mandrill'
!!     mandrill = Mandrill::API.new '-q-BEin2lOraKbC6UOJsPw'
!!     message = {"from_name"=>"Stuffmapper",
--                "from_email"=>"contactl@stuffmapper.com",
--                "subject"=>subject,
--                "to"=> [{"email"=>@receiver.email}],
--                "text"=>text_content,
--                "html"=>html_content,
--     }
-- 
!!     async = false
!!     result = mandrill.messages.send message, async, "Main Pool"
!!     logger.debug "Mandrill result: #{result}"
-- 
--   rescue Mandrill::Error => e
!!     logger.debug "Mandrill error occurred: #{e.class} - #{e.message}"
--   end
-- 
-- 
--   # to make sure we don't expose it
     def ip
!!     ''
--   end
-- end

================================================================================
 ./app/models/post.rb
================================================================================
   class Post < ActiveRecord::Base
--   
     belongs_to :user, :class_name => User
     has_many :dibs, :class_name => Dib, :foreign_key => :post_id
     has_attached_file :image,
--     :styles => { :medium => "300x300>" }, :default_url => "/images/:style/missing.png",
--     :storage => :s3,
--     :s3_credentials => "#{Rails.root}/config/aws.yml"
-- 
     validates_attachment_content_type :image, :content_type => /\Aimage\/.*\Z/
     attr_readonly :creator_id
     STATUSES = [STATUS_NEW = 'new', STATUS_DELETED = 'deleted', STATUS_CLAIMED = 'claimed', STATUS_DIBBED = 'dibbed']
--   
     default_scope { order('created_at DESC') }
-- 
     validates_attachment_presence :image
     validates_presence_of :creator_id
     validates_presence_of :longitude, :latitude
     validates :status, inclusion: {in: STATUSES}
     after_validation :update_image
-- 
     def send_message_to_creator (dibber, body, subject)
!!     dibber.send_message( User.find(self.creator_id), body,subject) 
--   end
-- 
     def create_new_dib (dibber, request_ip='')
!!     dib = self.dibs.build
!!     dib.ip = request_ip
!!     dib.status = 'new'
!!     dib.creator_id = dibber.id 
!!     dib.valid_until = Time.now + Dib.timeSpan
!!     if dib.save
!!       self.dibbed_until = dib.valid_until
!!       self.status == 'dibbed'
!!       self.dibber_id = dibber.id
!!       self.save
!!       send_message_to_creator(dibber, (dibber.username + "'s dibbed your stuff!" ), " Respond to this message to get in contact")
--     end
!!     dib
--   end
-- 
     def available_to_dib? 
!!     self.status == 'new' && self.dibbed_until == nil || self.dibbed_until <= Time.now
--   end
-- 
-- 
-- 
     def coords
!!     {'lat'=> self.latitude, 'lng'=> self.longitude }
--   end
-- 
     def creator
!!     return User.find(self.creator_id)
--   end
-- 
-- 
     def ip
!!     ''
--   end
-- 
     protected
-- 
     def update_image
-- 
!!     self.image_url = self.image.url(:medium)
--   end
-- 
-- end

================================================================================
 ./app/models/user.rb
================================================================================
   class User < ActiveRecord::Base
     has_many :posts, :class_name => Post, :foreign_key => :creator_id
     has_many :dibs, :class_name => Dib, :foreign_key => :creator_id
     has_many :messages, :class_name => Message, :foreign_key => :sender_id
     STATUSES = [STATUS_NEW = 'new', STATUS_DELETED = 'deleted']
--   
--   # attr_accessor allows you to use the password attribute locally, but will not persist it to the database
     attr_accessor :password
     before_save :encrypt_password
--   
     validates_presence_of :first_name
     validates_presence_of :last_name
     validates_uniqueness_of :username
     validates_confirmation_of :password
     validates_presence_of :password, :on => :create
     validates_format_of :email, :with => /\A[^@]+@([^@\.]+\.)+[^@\.]+\z/
     validates :status, inclusion: {in: STATUSES}
     acts_as_messageable
-- 
     def save(*args)
!!     super
--   rescue ActiveRecord::RecordNotUnique => error
!!     errors[:base] << "Duplicate username or email"
!!     false
--   end
-- 
     def self.authenticate(username, password)
       user = find_by_username(username)
       if user && user.status == STATUS_NEW && user.password_hash == BCrypt::Engine.hash_secret(password, user.password_salt)
!!       user
--     else
--       nil
--     end
--   end
--   
     def encrypt_password
       if password.present?
         self.password_salt = BCrypt::Engine.generate_salt
         self.password_hash = BCrypt::Engine.hash_secret(password, password_salt)
--     end
--   end
-- 
     def mailboxer_email(object)
!!     self.email
--   end
-- 
--   # to make sure we don't expose it
     def ip
       ''
--   end
-- end

