metric_fu shift the first line
================================================================================
 ./app/controllers/application_controller.rb
================================================================================
   class ApplicationController < ActionController::Base
--   # Prevent CSRF attacks by raising an exception.
--   # For APIs, you may want to use :null_session instead.
     protect_from_forgery with: :exception
--   
     helper_method :current_user
--   
-- 
     private
-- 
     def current_user
       @current_user ||= User.find(session[:user_id]) if session[:user_id]
--   end
-- 
-- end
-- 
--  
-- 

================================================================================
 ./app/controllers/dibs_controller.rb
================================================================================
   class DibsController < ApplicationController
-- 
-- 
   def create
       if current_user && params[:post_id] 
-- 
         @post = Post.find(params[:post_id])
--     
         if @post.available_to_dib?
            @post.create_new_dib(current_user, request.remote_ip)
            render json: '[]', status: :ok 
--       end
--     else
         render json: '[]', status: :unprocessable_entity
--     end
--   end
-- 
     private
-- 
-- 
-- end

================================================================================
 ./app/controllers/messages_controller.rb
================================================================================
   class MessagesController < ApplicationController
     before_filter :verify_logged_in
-- 
     def index
       @messages = current_user.mailbox.inbox
       render json: @messages, status: :ok
--   end
-- 
     def show
       conversation = current_user.mailbox.conversations.where(:id => params[:id])[0]
       receipts = conversation.receipts
       messages = receipts.collect{ |receipt| receipt.message }
       render json: messages, status: :ok
--   
--   end
-- 
     def update
        conversation = current_user.mailbox.conversations.where(:id => params[:id])[0]
-- 
        current_user.reply_to_conversation(conversation, message_params[:body])
-- 
        receipts = conversation.receipts
        messages = receipts.collect{ |receipt| receipt.message }
-- 
        render json: messages, status: :ok
--      
--   end
-- 
--   # POST /messages
--   # POST /messages.json
     def create
!!     @message = Message.new(message_params.merge(:ip => request.remote_ip, :status => 'new', :sender_id => session[:user_id], :sender_name => User.find(session[:user_id]).name, :receiver_name =>  User.find(message_params[:receiver_id]).name))
-- 
--     # ensures that the models errors array is populated so that if the captcha is incorrect the user will see that message as well as all the model error validation messages.
!!     respond_to do |format|
!!       @message.valid?
!!       if @message.save
!!         @message.send_notification("You just got a message!", "Please, go to Stuffmapper.com to check it out.", "Please, go to <a href=\"http://stuffmapper.com\">Stuffmapper.com</a> to check it out.")
!!         format.json {render json: '[]', status: :ok}
--       else
!!         format.json {render json: @message.errors, status: :unprocessable_entity}
--       end
--     end
--   end
-- 
     private
--     # Use callbacks to share common setup or constraints between actions.
-- 
       def verify_logged_in
         if not current_user 
           render json: '[]', status: :unauthorized
--       end
--     end
-- 
--     # Never trust parameters from the scary internet, only allow the white list through.
       def message_params
         params.require(:message).permit(:receiver_username, :body, :subject)
--     end
-- end

================================================================================
 ./app/controllers/posts_controller.rb
================================================================================
   class PostsController < ApplicationController
--  
     before_action :set_post, only: [:show, :claim]
--         #this should be part of the model _ on save
-- 
--   # GET /posts
--   # GET /posts.json
-- 
     def index
!!     user_ip = request.location
--     
!!     if !user_ip.longitude == 0.0
!!       @map_center = {'latitude'=> user_ip.latitude, 'longitude'=> user_ip.longitude }.to_json
--     else
!!     @map_center = {'latitude'=> 47.6097, 'longitude'=> -122.3331 }.to_json
--     end
--   end
-- 
--   # POST /posts
--   # POST /posts.json
     def create
       if (current_user)
         cleaned_params = post_params.delete_if{ |key, value| value == 'undefined'  }
         @user = User.find( current_user.id )
         @post = Post.new(cleaned_params.merge(:ip => request.remote_ip, :status => 'new', :creator_id => @user.id ))
         if @post.save
           @post.save
           render json: '[]', status: :ok
--       else
           render json: @post.errors, status: :unprocessable_entity
--       end
--     else
         render json: {error: 'not authorized '}, status: :unauthorized
--     end
--   end
--   
--   # POST /posts/dib/1
--   # POST /posts/dib/1.json
     def dib
!!     if current_user && dib_params[:id] 
-- 
!!       @post = Post.find(dib_params[:id])
--     
!!       if @post.available_to_dib?
!!          @post.create_new_dib(current_user)
!!          add_dib(@post, request, current_user)
!!          render json: '[]', status: :ok 
--       end
--     else
!!       render json: '[]', status: :unprocessable_entity
--     end
--   end
-- 
--   # POST /posts/claim/1
--   # POST /posts/claim/1.json
-- 
     def geolocated 
       @posts = Post.where(:latitude => params[:swLat]..params[:neLat])
--                  .where(:longitude => params[:swLng]..params[:neLng])
       render json: @posts
--   end
-- 
--   # POST /posts/grid_mode.json
     def grid_mode
!!     session[:grid_mode] = params[:grid_mode]
!!     if (current_user)
!!       current_user.grid_mode = session[:grid_mode]
!!       current_user.save
--     end
!!     respond_to do |format|
!!         format.json {render json: '[]', status: :ok}
--     end
--   end
-- 
--   # GET /posts/search
     def search
!!     @posts = Post.where("title ILIKE ? AND status = ? AND (dibbed_until IS NULL OR (dibbed_until IS NOT NULL AND dibbed_until <= NOW()))", "%#{params[:term]}%", 'new').page(params[:page]).per(6)
!!     @term = params[:term]
!!     if (current_user)
!!       @post = Post.new(:on_the_curb => 1, :phone_number => current_user.phone_number)
!!       @message = Message.new()
--     else
!!       @user = User.new
--     end
!!     render action: 'index'
--   end
-- 
--   # GET /posts/my_stuff
     def my_stuff
       if (current_user)
         @posts = Post.where(:creator_id => current_user.id )
         render json: @posts
--     else
         render json: {message: 'User not logged in' }, status: :unauthorized
--     end
--   end
-- 
-- 
     private
--     # Use callbacks to share common setup or constraints between actions.
       def set_post
!!       @post = Post.find(params[:id])
--     end
-- 
--     # Never trust parameters from the scary internet, only allow the white list through.
       def post_params
         params.permit(:image,:category, :latitude, :longitude)
--     end
-- 
-- 
-- 
-- end

================================================================================
 ./app/controllers/sessions_controller.rb
================================================================================
   class SessionsController < ApplicationController
     def create
--     
       user = User.authenticate(params[:username], params[:password])
-- 
         if user
           session[:user_id] = user.id
           session[:latitude] = user.latitude
           session[:longitude] = user.longitude
           session[:zoom] = user.zoom
           session[:grid_mode] = user.grid_mode
           render json: {user:user.username}, status: :ok
--       else
--         
           render json: '[]', status: :unprocessable_entity
--       end
--   end
-- 
     def destroy
       session[:user_id] = nil
       session[:latitude] = nil
       session[:longitude] = nil
       session[:zoom] = nil
       session[:grid_mode] = nil
       render json: '[]', status: :ok
--   end
-- 
     def check
       if current_user
-- 
         render json: {message: 'User is logged in', user: current_user.username }, status: :ok
--     else
         render json: {message: 'User not logged in' }, status: :unauthorized
--     end
-- 
--   end
-- 
     private
--     # Never trust parameters from the scary internet, only allow the white list through.
       def sessions_params
!!       params.permit(:username, :password)
--     end
-- end
-- 

================================================================================
 ./app/controllers/users_controller.rb
================================================================================
   class UsersController < ApplicationController
     before_action :set_user, only: [:show, :my_stuff]
-- 
--   # GET /users/1"111"
--   # GET /users/1.json
     def show
--   end
-- 
--   # POST /users
--   # POST /users.json
     def create
       @user = User.new(user_params.merge(:ip => request.remote_ip, :status => 'new'))
       @user.latitude = session[:latitude]
       @user.longitude = session[:longitude]
       @user.zoom = session[:zoom]
       @user.grid_mode = session[:grid_mode]
-- 
-- 
--  
--     
       if @user.save
         session[:user_id] = @user.id
         render json: '[]', status: :ok
--     else
         render json: @user.errors, status: :unprocessable_entity
--     end
--   
--   end
-- 
--   # POST /users
--   # POST /users.json
     def my_stuff
!!     respond_to do |format|
!!       @user.valid?
!!       if @user.update(user_params)
!!         format.json {render json: '[]', status: :ok}
--       else
!!         format.json {render json: @user.errors, status: :unprocessable_entity}
--       end
--     end
--   end
-- 
-- 
-- 
--   # POST /users/presets.json
     def presets
!!     if !session[:latitude]
!!       session[:latitude] = 47.6612588;
--     end
!!     if !session[:longitude]
!!       session[:longitude] = -122.3078193;
--     end
!!     if !session[:zoom]
!!       session[:zoom] = 14;
--     end
!!     if !session[:grid_mode]
!!       session[:grid_mode] = true;
--     end
-- 
!!     respond_to do |format|
!!       format.json {render json: '{"latitude":'+session[:latitude].to_s+',
--         "longitude":'+session[:longitude].to_s+',
--         "zoom":'+session[:zoom].to_s+',
--         "grid_mode":'+session[:grid_mode].to_s+'}', status: :ok}
--     end
--   end
-- 
     private
--     # Use callbacks to share common setup or constraints between actions.
       def set_user
!!       @user = User.find(params[:id])
--     end
-- 
--     # Never trust parameters from the scary internet, only allow the white list through.
       def user_params
         params.require(:user).permit(:first_name,:last_name, :username, :email, :password, :password_confirmation, :address, :latitude, :longitude, :on_the_curb, :phone_number)
--     end
-- end

================================================================================
 ./app/helpers/application_helper.rb
================================================================================
   module ApplicationHelper
-- end

================================================================================
 ./app/helpers/dibs_controller_helper.rb
================================================================================
   module DibsControllerHelper
-- end

================================================================================
 ./app/helpers/dibs_helper.rb
================================================================================
   module DibsHelper
-- end

================================================================================
 ./app/helpers/feedbacks_helper.rb
================================================================================
   module FeedbacksHelper
-- end

================================================================================
 ./app/helpers/messages_helper.rb
================================================================================
   module MessagesHelper
-- end

================================================================================
 ./app/helpers/posts_helper.rb
================================================================================
   module PostsHelper
-- end

================================================================================
 ./app/helpers/sessions_helper.rb
================================================================================
   module SessionsHelper
-- end

================================================================================
 ./app/helpers/users_helper.rb
================================================================================
   module UsersHelper
-- end

================================================================================
 ./app/models/dib.rb
================================================================================
   class Dib < ActiveRecord::Base
     belongs_to :user, :class_name => User
     belongs_to :post, :class_name => Post
--   
     STATUSES = [STATUS_NEW = 'new', STATUS_DELETED = 'deleted', STATUS_FINISHED = 'finished']
-- 
--   # 43200 seconds = 12 hours
     @@timeSpan = 43200
     cattr_reader :timeSpan
--   
     validates_presence_of :creator_id
     validates_presence_of :post_id
     validates :status, inclusion: {in: STATUSES}
-- 
-- 
--   # to make sure we don't expose it
     def ip
       ''
--   end
-- end

================================================================================
 ./app/models/message.rb
================================================================================
   class Message < ActiveRecord::Base
     belongs_to :user, :class_name => User, :foreign_key => :sender_id
     belongs_to :user, :class_name => User, :foreign_key => :receiver_id
     attr_readonly :creator_id
-- 
     STATUSES = [STATUS_NEW = 'new', STATUS_DELETED = 'deleted', STATUS_READ = 'read']
-- 
     default_scope { order('created_at DESC') }
-- 
     validates_presence_of :sender_id
     validates_presence_of :receiver_id
     validates_presence_of :content
     validates :status, inclusion: {in: STATUSES}
-- 
     def send_notification(subject, text_content, html_content)
!!     @receiver = User.find(self.receiver_id)
-- 
!!     require 'mandrill'
!!     mandrill = Mandrill::API.new '-q-BEin2lOraKbC6UOJsPw'
!!     message = {"from_name"=>"Stuffmapper",
--                "from_email"=>"contactl@stuffmapper.com",
--                "subject"=>subject,
--                "to"=> [{"email"=>@receiver.email}],
--                "text"=>text_content,
--                "html"=>html_content,
--     }
-- 
!!     async = false
!!     result = mandrill.messages.send message, async, "Main Pool"
!!     logger.debug "Mandrill result: #{result}"
-- 
--   rescue Mandrill::Error => e
!!     logger.debug "Mandrill error occurred: #{e.class} - #{e.message}"
--   end
-- 
-- 
--   # to make sure we don't expose it
     def ip
!!     ''
--   end
-- end

================================================================================
 ./app/models/post.rb
================================================================================
   class Post < ActiveRecord::Base
--   
     belongs_to :user, :class_name => User
     has_many :dibs, :class_name => Dib, :foreign_key => :post_id
     has_attached_file :image,
--     :styles => { :medium => "300x300>" }, :default_url => "/images/:style/missing.png",
--     :storage => :s3,
--     :s3_credentials => "#{Rails.root}/config/aws.yml"
-- 
     validates_attachment_content_type :image, :content_type => /\Aimage\/.*\Z/
     attr_readonly :creator_id
     STATUSES = [STATUS_NEW = 'new', STATUS_DELETED = 'deleted', STATUS_CLAIMED = 'claimed', STATUS_DIBBED = 'dibbed']
--   
     default_scope { order('created_at DESC') }
-- 
     validates_attachment_presence :image
     validates_presence_of :creator_id
     validates_presence_of :longitude, :latitude
     validates :status, inclusion: {in: STATUSES}
     after_validation :update_image
-- 
     def send_message_to_creator (dibber, body, subject)
       dibber.send_message( User.find(self.creator_id), body,subject) 
--   end
-- 
     def create_new_dib (dibber, request_ip='')
       self.dibbed_until = Time.now + Dib.timeSpan
       self.status == 'dibbed'
       self.dibber_id = dibber.id
       self.save
       dib = self.dibs.build
       dib.ip = request_ip
       dib.valid_until = self.dibbed_until
       dib.status = 'new'
       dib.creator_id = dibber.id 
       dib.save
       send_message_to_creator(dibber, (dibber.username + " Has dibbed your stuff" ), " respond_to this message to get in contact")
--   end
-- 
     def available_to_dib?
       self.status == 'new' && self.dibbed_until == nil || self.dibbed_until <= Time.now
--   end
-- 
-- 
-- 
     def coords
!!     {'lat'=> self.latitude, 'lng'=> self.longitude }
--   end
-- 
-- 
-- 
-- 
     def ip
       ''
--   end
-- 
     protected
-- 
     def update_image
-- 
       self.image_url = self.image.url(:medium)
--   end
-- 
-- end

================================================================================
 ./app/models/user.rb
================================================================================
   class User < ActiveRecord::Base
     has_many :posts, :class_name => Post, :foreign_key => :creator_id
     has_many :dibs, :class_name => Dib, :foreign_key => :creator_id
     has_many :messages, :class_name => Message, :foreign_key => :sender_id
     STATUSES = [STATUS_NEW = 'new', STATUS_DELETED = 'deleted']
--   
--   # attr_accessor allows you to use the password attribute locally, but will not persist it to the database
     attr_accessor :password
     before_save :encrypt_password
--   
     validates_presence_of :first_name
     validates_presence_of :last_name
     validates_uniqueness_of :username
     validates_confirmation_of :password
     validates_presence_of :password, :on => :create
     validates_format_of :email, :with => /\A[^@]+@([^@\.]+\.)+[^@\.]+\z/
     validates :status, inclusion: {in: STATUSES}
     acts_as_messageable
-- 
     def self.authenticate(username, password)
       user = find_by_username(username)
       if user && user.status == STATUS_NEW && user.password_hash == BCrypt::Engine.hash_secret(password, user.password_salt)
         user
--     else
--       nil
--     end
--   end
--   
     def encrypt_password
       if password.present?
         self.password_salt = BCrypt::Engine.generate_salt
         self.password_hash = BCrypt::Engine.hash_secret(password, password_salt)
--     end
--   end
-- 
     def mailboxer_email(object)
!!     self.email
--   end
-- 
--   # to make sure we don't expose it
     def ip
       ''
--   end
-- end

================================================================================
 ./app/serializers/post_serializer.rb
================================================================================
   class PostSerializer < ActiveModel::Serializer
     attributes :id, :latitude, :longitude, :image_url, :coords, :image_url
-- 
     def coords
       {'latitude'=> self.latitude, 'longitude'=> self.longitude }
--   end
-- end

================================================================================
 ./config/application.rb
================================================================================
   require File.expand_path('../boot', __FILE__)
-- 
   require 'rails/all'
-- 
-- # Require the gems listed in Gemfile, including any gems
-- # you've limited to :test, :development, or :production.
   Bundler.require(:default, Rails.env)
-- 
   module Dibsly
     class Application < Rails::Application
--     # Settings in config/environments/* take precedence over those specified here.
--     # Application configuration should go into files in config/initializers
--     # -- all .rb files in that directory are automatically loaded.
-- 
--     # Set Time.zone default to the specified zone and make Active Record auto-convert to this zone.
--     # Run "rake -D time" for a list of tasks for finding time zone names. Default is UTC.
--     # config.time_zone = 'Central Time (US & Canada)'
-- 
--     # The default locale is :en and all translations from config/locales/*.rb,yml are auto loaded.
--     # config.i18n.load_path += Dir[Rails.root.join('my', 'locales', '*.{rb,yml}').to_s]
--     # config.i18n.default_locale = :de
       config.assets.paths << Rails.root.join("vendor","assets","bower_components")
       config.assets.paths << Rails.root.join("vendor","assets","bower_components","bootstrap-sass-official","assets","fonts")
       config.assets.precompile << %r(.*.(?:eot|svg|ttf|woff|woff2)$)
-- 
--   end
-- end

================================================================================
 ./config/boot.rb
================================================================================
-- # Set up gems listed in the Gemfile.
   ENV['BUNDLE_GEMFILE'] ||= File.expand_path('../../Gemfile', __FILE__)
-- 
   require 'bundler/setup' if File.exists?(ENV['BUNDLE_GEMFILE'])

================================================================================
 ./config/environment.rb
================================================================================
-- # Load the Rails application.
   require File.expand_path('../application', __FILE__)
-- 
-- # Initialize the Rails application.
   Dibsly::Application.initialize!

================================================================================
 ./config/environments/test.rb
================================================================================
   Dibsly::Application.configure do
--   # Settings specified here will take precedence over those in config/application.rb.
     config.middleware.use RackSessionAccess::Middleware
--   # The test environment is used exclusively to run your application's
--   # test suite. You never need to work with it otherwise. Remember that
--   # your test database is "scratch space" for the test suite and is wiped
--   # and recreated between test runs. Don't rely on the data there!
     config.cache_classes = true
--  
--   # Do not eager load code on boot. This avoids loading your whole application
--   # just for the purpose of running a single test. If you are using a tool that
--   # preloads Rails for running tests, you may have to set it to true.
     config.eager_load = false
-- 
--   # Configure static asset server for tests with Cache-Control for performance.
     config.serve_static_files = true
     config.static_cache_control = "public, max-age=3600"
-- 
--   # Show full error reports and disable caching.
     config.consider_all_requests_local       = true
     config.action_controller.perform_caching = false
-- 
--   # Raise exceptions instead of rendering exception templates.
     config.action_dispatch.show_exceptions = false
-- 
--   # Disable request forgery protection in test environment.
     config.action_controller.allow_forgery_protection = false
-- 
--   # Tell Action Mailer not to deliver emails to the real world.
--   # The :test delivery method accumulates sent emails in the
--   # ActionMailer::Base.deliveries array.
     config.action_mailer.delivery_method = :test
-- 
     config.active_record.raise_in_transactional_callbacks = true
--   # Print deprecation notices to the stderr.
     config.active_support.deprecation = :stderr
     config.paperclip_defaults = {
--   :s3_host_name => 's3-us-west-2.amazonaws.com',
--   :storage => :s3,
--   :s3_credentials => {
--     :bucket => 'stuffmapper-dev'
--   }
-- }
-- end
-- 
   Rails.application.routes.default_url_options[:host] = '???'

================================================================================
 ./config/initializers/assets.rb
================================================================================
   Rails.application.config.assets.precompile += %w( 
--   teaspoon.css
--   teaspoon-teaspoon.js
--   teaspoon-jasmine.js
-- )

================================================================================
 ./config/initializers/backtrace_silencers.rb
================================================================================
-- # Be sure to restart your server when you modify this file.
-- 
-- # You can add backtrace silencers for libraries that you're using but don't wish to see in your backtraces.
-- # Rails.backtrace_cleaner.add_silencer { |line| line =~ /my_noisy_library/ }
-- 
-- # You can also remove all the silencers if you're trying to debug a problem that might stem from framework code.
-- # Rails.backtrace_cleaner.remove_silencers!

================================================================================
 ./config/initializers/filter_parameter_logging.rb
================================================================================
-- # Be sure to restart your server when you modify this file.
-- 
-- # Configure sensitive parameters which will be filtered from the log file.
   Rails.application.config.filter_parameters += [:password]

================================================================================
 ./config/initializers/geocoder.rb
================================================================================
   Geocoder.configure(
--   # geocoding options
--   # :timeout      => 3,           # geocoding service timeout (secs)
--   # :lookup       => :google,     # name of geocoding service (symbol)
--   # :language     => :en,         # ISO-639 language code
--   # :use_https    => false,       # use HTTPS for lookup requests? (if supported)
--   # :http_proxy   => nil,         # HTTP proxy server (user:pass@host:port)
--   # :https_proxy  => nil,         # HTTPS proxy server (user:pass@host:port)
--   # :api_key      => nil,         # API key for geocoding service
--   # :cache        => nil,         # cache object (must respond to #[], #[]=, and #keys)
--   # :cache_prefix => "geocoder:", # prefix (string) to use for all cache keys
--   
--   # exceptions that should not be rescued by default
--   # (if you want to implement custom error handling);
--   # supports SocketError and TimeoutError
--   # :always_raise => [],
-- 
--   # calculation options
--   # :units     => :mi,       # :km for kilometers or :mi for miles
--   # :distances => :linear    # :spherical or :linear
--     :lookup => :bing, 
--     :api_key => 'At4V1cWbwV6EWaLug6Kkz4FmG5-bKbI-JNRqHG2g3MGcrsafhDuqGr1rtWjf30-3' )

================================================================================
 ./config/initializers/inflections.rb
================================================================================
-- # Be sure to restart your server when you modify this file.
-- 
-- # Add new inflection rules using the following format. Inflections
-- # are locale specific, and you may define rules for as many different
-- # locales as you wish. All of these examples are active by default:
-- # ActiveSupport::Inflector.inflections(:en) do |inflect|
-- #   inflect.plural /^(ox)$/i, '\1en'
-- #   inflect.singular /^(ox)en/i, '\1'
-- #   inflect.irregular 'person', 'people'
-- #   inflect.uncountable %w( fish sheep )
-- # end
-- 
-- # These inflection rules are supported but not enabled by default:
-- # ActiveSupport::Inflector.inflections(:en) do |inflect|
-- #   inflect.acronym 'RESTful'
-- # end

================================================================================
 ./config/initializers/mailboxer.rb
================================================================================
   Mailboxer.setup do |config|
--   #Enables or disables email sending for Notifications and Messages
     config.uses_emails = false
--   #Configures the default `from` address for the email sent for Messages and Notifications of Mailboxer
     config.default_from = "no-reply@dit.upm.es"
--  
-- end

================================================================================
 ./config/initializers/mime_types.rb
================================================================================
-- # Be sure to restart your server when you modify this file.
-- 
-- # Add new mime types for use in respond_to blocks:
-- # Mime::Type.register "text/richtext", :rtf
-- # Mime::Type.register_alias "text/html", :iphone

================================================================================
 ./config/initializers/recaptcha.rb
================================================================================
   Recaptcha.configure do |config|
     config.public_key  = '6Leo0vgSAAAAAHu-_4bT70rAbA9e3fTAaZc4mQg_'
     config.private_key = '6Leo0vgSAAAAAM49CNca9qyfrhVDdAy5fVHIRfsl'
-- end

================================================================================
 ./config/initializers/secret_token.rb
================================================================================
-- # Be sure to restart your server when you modify this file.
-- 
-- # Your secret key is used for verifying the integrity of signed cookies.
-- # If you change this key, all old signed cookies will become invalid!
-- 
-- # Make sure the secret is at least 30 characters and all random,
-- # no regular words or you'll be exposed to dictionary attacks.
-- # You can use `rake secret` to generate a secure secret key.
-- 
-- # Make sure your secret_key_base is kept private
-- # if you're sharing your code publicly.
   Dibsly::Application.config.secret_key_base = '83ef7ab6a657f9821034a6a5e4863e0f5595e7552d4a52e3391f638e73355cc9bac203cb902f0d5b9c5f3bac898d64696494adbf9fe4caf523e8df9f2ce16bbe'

================================================================================
 ./config/initializers/session_store.rb
================================================================================
-- # Be sure to restart your server when you modify this file.
-- 
   Dibsly::Application.config.session_store :cookie_store, key: '_dibsly_session'

================================================================================
 ./config/initializers/wrap_parameters.rb
================================================================================
-- # Be sure to restart your server when you modify this file.
-- 
-- # This file contains settings for ActionController::ParamsWrapper which
-- # is enabled by default.
-- 
-- # Enable parameter wrapping for JSON. You can disable this by setting :format to an empty array.
   ActiveSupport.on_load(:action_controller) do
     wrap_parameters format: [:json] if respond_to?(:wrap_parameters)
-- end
-- 
-- # To enable root element in JSON for ActiveRecord objects.
-- # ActiveSupport.on_load(:active_record) do
-- #  self.include_root_in_json = true
-- # end

================================================================================
 ./config/routes.rb
================================================================================
   Dibsly::Application.routes.draw do
     post 'sessions/create'
     get 'log_out' => 'sessions#destroy', :as => 'log_out'
     get '/auth/check' => 'sessions#check'
-- 
     post 'users' => 'users#create'
     patch 'users/:id' => 'users#my_stuff'
     post 'users/:id', :to => 'users#show', :as => :user
     post 'presets' => 'users#presets'
-- 
     resources :messages
-- 
     get 'posts' => 'posts#index'
     post 'posts' => 'posts#create'
     get 'posts/geolocated' => 'posts#geolocated'
     post 'posts/grid_mode' => 'posts#grid_mode'
     get 'search' => 'posts#search'
     get 'my-stuff' => 'posts#my_stuff'
     post 'feedbacks/create'
-- 
     resources :posts do 
       resources :dibs 
--   end
-- 
     root 'posts#index'
-- 
     get '(*url)' => 'posts#index'
-- end

================================================================================
 ./spec/controllers/messages_controller_spec.rb
================================================================================
   require 'rails_helper'
-- 
   RSpec.describe MessagesController, :type => :controller do
-- 	
   	before do
   		@user = create(:user)
   		@user2 = create(:user)
-- 	end
-- 
   	describe "Get index" do
   		it "shouldn't return messages when not logged in" do 
-- 
   			xhr :get, :index 
   		    expect(response.status).to eq(401) 
-- 		end
   		it "should return 200 when logged in" do 
   			sign_in(@user)
-- 
   			xhr :get, :index 
   		    expect(response.status).to eq(200) 
-- 		end
   		it "should return messages when logged in" do 
   			@user2.send_message(@user,"Body","This is aSubject")
--    
   			sign_in(@user)
-- 			 
   			xhr :get, :index 
   		    expect(response.status).to eq(200) 
   		    response_first_subject = JSON.parse(response.body)['messages'][0]['subject']
   		    expect(response_first_subject).to eq("This is aSubject") 
-- 		end
-- 
-- 	end
   	describe "Get show conversation" do
   		before do 
   			@user2.send_message(@user,"This is the Body","This is aSubject")
   			@conversation =  @user.mailbox.inbox.last
--       	end
--       	#receipts.each {|receipt| expect(receipt.message.body).to eq("#{@user2.username} Has dibbed your stuff") }
-- 
   		it "shouldn't return messages when not logged in" do 
   			xhr :get, :show, :id => @conversation.id  
   		    expect(response.status).to eq(401) 
-- 		end
   		it "should return 200 when logged in" do 
   			sign_in(@user)
   			xhr :get, :show, :id => @conversation.id  
   		    expect(response.status).to eq(200) 
-- 		end
-- 
   		it "should return messages for converstion to be returned" do 
   			sign_in(@user)
   			xhr :get, :show, :id => @conversation.id  
   		    expect(response.status).to eq(200) 
   		    response_first_body = JSON.parse(response.body)['messages'][0]['body']
   		    expect(response_first_body).to eq('This is the Body')
-- 		end
-- 	end
-- 
   	describe "Get reply to conversation" do
   		before do 
   			@user2.send_message(@user,"This is the Body","This is aSubject")
   			@conversation =  @user.mailbox.inbox.last
--       	end
--       	#receipts.each {|receipt| expect(receipt.message.body).to eq("#{@user2.username} Has dibbed your stuff") }
-- 
   		it "shouldn't return messages when not logged in" do 
   			xhr :post, :update, :id => @conversation.id 
   		    expect(response.status).to eq(401) 
-- 		end
   		it "should return 200 when logged in" do 
   			sign_in(@user)
   			xhr :post, :update, :id => @conversation.id , :message => {:body => "I'm replying to the last post" }
   		    expect(response.status).to eq(200) 
-- 		end
-- 
   		it "should return messages for converstion to be returned" do 
   			sign_in(@user)
   			xhr :post, :update, :id => @conversation.id , :message => {:body => "I'm replying to the last post" } 
   		    expect(response.status).to eq(200) 
   		    response_first_body = JSON.parse(response.body)['messages'][0]['body']
   		    expect(response_first_body).to eq("I'm replying to the last post")
-- 		end
-- 	end
-- 
-- end

================================================================================
 ./spec/controllers/posts_controller_spec.rb
================================================================================
   require 'rails_helper'
-- 
   RSpec.describe PostsController, :type => :controller do
   	vcr_options = { :cassette_name => "aws", :match_requests_on => [:method] }
-- 	
   	describe "Get geolocated", :vcr => vcr_options do
-- 		 
-- 
   		before do
   			@user = create(:user)
   		    @post = build(:post, creator_id: @user.id )
-- 	
-- 	
-- 		#Paperclip::Attachment.any_instance.stub(:save_attached_files).and_return(true)
-- 	
-- 		end
   		context "when there are far and near posts " do
   			before do
   			   @post.latitude = '49'
   			   @post.longitude = '-122'
   			   @post.save!
-- 			end
-- 
   			it "200 does" do
-- 
   			  xhr :get, :geolocated
   			  expect(response.body).to eq "{\"posts\":[]}"
   			  expect(response.status).to eq(200)
--  
-- 			end
-- 
   			it "only returns a nearby post" do
-- 			   
   			   @post.latitude = '47'
   			   @post.longitude = '-122'
   			   @post.save!
   			   xhr :get, :geolocated, :neLat => 48, :neLng => -121, :swLat => 46, :swLng => -123
-- 		       #ugly need to fix
   		       parsed_response = JSON.parse(response.body.as_json)
   			   expect(parsed_response['posts'][0]['id'] ).to eq @post.id
   			   expect(parsed_response['posts'][0]['coords'] ).to eq JSON.parse('{"latitude":47.0, "longitude":-122.0}')
   			   expect(response.status).to eq(200)
-- 			end
-- 			
   			it "does not returns post out of scope " do
-- 
   			   xhr :get, :geolocated, :neLat => 48, :neLng => -121, :swLat => 46, :swLng => -123
-- 		       #ugly need to fix
   		       parsed_response = JSON.parse(response.body.as_json)
   			   expect(parsed_response['posts'][0]).to eq nil
   			   expect(response.status).to eq(200)   
-- 
-- 			end
   			it "does not returns post out of scope " do
-- 			  
   			   xhr :get, :geolocated, :neLat => 48, :neLng => -121, :swLat => 46, :swLng => -123
-- 		       #ugly need to fix
   		       parsed_response = JSON.parse(response.body.as_json)
   			   expect(parsed_response['posts'][0]).to eq nil
   			   expect(response.status).to eq(200)   
-- 			end
   			it "returns a post with an image_url" do
-- 			   
   			   @post.latitude = '47'
   			   @post.longitude = '-122'
   			   @post.save!
   			   xhr :get, :geolocated, :neLat => 48, :neLng => -121, :swLat => 46, :swLng => -123
-- 		       #ugly need to fix
   		       parsed_response = JSON.parse(response.body.as_json)
   			   expect(parsed_response['posts'][0]['id'] ).to eq @post.id
   			   expect(parsed_response['posts'][0]['image_url'] ).to match(/http:\/\/s3-us-west-2.amazonaws.com\/stuffmapper-test\/posts\/image/)
   			   expect(response.status).to eq(200)
-- 			end
-- 		end
-- 	end
   	describe "Post create post", :vcr => vcr_options do
   		before do
   			@user = create(:user)
-- 		end
-- 
   		context "without login " do 
-- 
   			it 'should 401' do 
   				xhr :post, :create 
   		     	expect(response.status).to eq(401) 
-- 			end
-- 		end
-- 
   		context "with login", :vcr => vcr_options do 
   			before do
   			shoes = File.read("spec/factories/shoes.png")
   			@file = fixture_file_upload(Rails.root.join("spec/factories/shoes.png"), 'image/png')
-- 			end
-- 
-- 
   			it 'should 422 with incomplete data' do 
   				sign_in(@user)
   				xhr :post, :create, {title:''} 
   				expect(response.body).to eq("{\"image\":[\"can't be blank\"],\"longitude\":[\"can't be blank\"],\"latitude\":[\"can't be blank\"]}")
   		     	expect(response.status).to eq(422) 
-- 			end
   			it 'should 422 without location data' do 
   				sign_in(@user)
   				xhr :post, :create, {title:'', image: @file } 
   				expect(response.body).to eq("{\"longitude\":[\"can't be blank\"],\"latitude\":[\"can't be blank\"]}")
   				expect(response.status).to eq(422) 
-- 			end
-- 			
   			it 'should 200 with complete data' do 
   				sign_in(@user)
   				xhr :post, :create, {title:'', image: @file, latitude:'47',longitude:'-122' } 
   				expect(response.status).to eq(200) 
-- 			end
-- 
-- 
-- 		end
-- 	end
   	describe "Get mystuff", :vcr => vcr_options do
-- 		 
-- 
   		before do
   			@user = create(:user)
   		    create(:post, creator_id: @user.id, latitude:'47',longitude:'-122'  ) 
-- 		end
   		context 'without login' do
   			it 'should return 401' do 
   				xhr :get, :my_stuff 
   		     	expect(response.status).to eq(401) 
-- 
-- 			end
-- 		end
-- 				
   		context 'with login' do
-- 
   			it 'should return 200' do 
   				sign_in(@user)
   				xhr :get, :my_stuff 
   		     	expect(response.status).to eq(200) 
-- 			end
-- 
-- 
   			it 'should return my stuff' do 
   				sign_in(@user)
   				xhr :get, :my_stuff 
   				parsed_response = JSON.parse(response.body.as_json)
   				expect(parsed_response['posts'][0]['coords'] ).to eq JSON.parse('{"latitude":47.0, "longitude":-122.0}')
   				expect(response.status).to eq(200)
-- 			end
-- 		end
-- 	end
-- 	
-- end

================================================================================
 ./spec/controllers/sessions_controller_spec.rb
================================================================================
   require 'rails_helper'
-- 
   RSpec.describe SessionsController, :type => :controller do
-- 
     describe "Post create" do
       before do
         user = create(:user, :username => 'Superbad' )
         xhr :post, :create, format: :json, username: username, password: password
--     end    
-- 
       context "with correct name " do
         let (:username) {'Superbad'}
         let (:password) {'123456'}
-- 
         it 'should 200' do
           expect(response.status).to eq(200)
           expect(JSON.parse(response.body)['user']).to eq('Superbad')
--       end
--     end
-- 
       context "with incorrect name " do
         let (:username) {'Superbland'}
         let (:password) {'123456'}
         it 'should 422' do
           expect(response.status).to eq(422)
-- 
--       end
--     end
-- 
--   end
-- 
     describe "Get Log out" do 
       it "should be successful" do 
--       
         xhr :get, :destroy, format: :json
         expect(response.status).to eq(200)
--     end
--   end
-- 
     describe "Get check user" do
       before do
         user = create(:user, :username => 'Superbad')
         xhr :post, :create, format: :json, username: 'Superbad', password: '123456'
--     end
-- 
       context "user logged in " do 
         it 'should 200' do
           xhr :get, :check
           expect(response.status).to eq(200)
           expect(JSON.parse(response.body)['user']).to eq('Superbad')
--       end
--     end
-- 
       context "user logged out " do
         it 'should 401' do
           xhr :get, :destroy, format: :json
           xhr :get, :check
           expect(response.status).to eq(401)
--       end
--     end
-- 
--   end   
-- end

================================================================================
 ./spec/controllers/users_controller_spec.rb
================================================================================
-- 
   require 'rails_helper'
-- 
   RSpec.describe UsersController, :type => :controller do
-- 
     describe "Post create" do
       before do
         xhr :post,:create, user: user_var
--     end
-- 
       context "When the data is complete" do
         let (:user_var) { {first_name: 'John', last_name: 'Smith', username: 'thing', email: 'fake@name.com', password: '123456', password_confirmation: '123456', username: 'Superbad'} }
-- 
         it 'should 200' do
           expect(response.status).to eq(200)
--       end
-- 
--     end
-- 
       context "When the data is incomplete" do
         let (:user_var) { {first_name: '', last_name: 'Smith', username: 'thing', email: 'fake@name.com', password: '123456', password_confirmation: '123456', username: 'Superbad'} }
-- 
         it 'should 422' do
           expect(response.status).to eq(422)
--       end
-- 
--     end
-- 
-- 
--   end
-- end

================================================================================
 ./spec/factories/post.rb
================================================================================
   include ActionDispatch::TestProcess
-- 
   FactoryGirl.define do
     factory :post do
       status "new"
       ip ""
       image { fixture_file_upload(Rails.root.join("spec/factories/shoes.png"), 'image/png') }
--   end
-- end
-- 

================================================================================
 ./spec/factories/user.rb
================================================================================
   FactoryGirl.define do
     factory :user do
       first_name "John"
       last_name  "Doe"
       sequence :username do |n|
           "Superbad#{n}"
--     end
       password "123456"
       password_confirmation "123456"
       sequence :email do |n|
           "Superbad#{n}@email.com"
--     end
--  
       status "new"
       ip ""
--   end
-- end

================================================================================
 ./spec/models/post_spec.rb
================================================================================
   require 'rails_helper'
-- 
   RSpec.describe Post, :type => :model do
     vcr_options = { :cassette_name => "aws", :match_requests_on => [:method] }
     describe "Model creation", :vcr => vcr_options  do 
     	before do
     		  @user = create(:user)
           @user2 = create(:user, {username: 'user2', email: 'anotherfake@email.com'})
           @post = create(:post, creator_id: @user.id, longitude: 0, latitude:0  ) 	
--     end
-- 
     	it "should have the correct attributes" do 
         expect(@post.latitude).to eq(0)
--   	end
       it "should send a message" do 
         @post.send_message_to_creator(@user2, 'this is a message', 'this is another thing')
         conversation =  @user.mailbox.inbox.last
         receipts = conversation.receipts_for @user
         receipts.each {|receipt| expect(receipt.message.body).to eq('this is a message') }
--     end
      it 'should be dibbable' do
       @post.create_new_dib(@user2)
-- 
-- 
--     end
     it 'should be available' do
       expect(@post.available_to_dib?).to eq(true)
-- 
-- 
--   end
-- 
-- end
-- 
-- 
-- end

================================================================================
 ./spec/support/authentication_helpers.rb
================================================================================
   module AuthenticationHelpers
-- 
     module Controller
   	  def sign_in(user)
   	    controller.stub(:current_user).and_return(user)
   	    controller.stub(:user_id).and_return(user.id)
-- 	  end
-- 	end
-- 
-- 
-- end

================================================================================
 ./spec/teaspoon_env.rb
================================================================================
-- # Set RAILS_ROOT and load the environment if it's not already loaded.
   unless defined?(Rails)
!!   ENV["RAILS_ROOT"] = File.expand_path("../../", __FILE__)
!!   require File.expand_path("../../config/environment", __FILE__)
-- end
-- 
   Teaspoon.configure do |config|
-- 
--   # Determines where the Teaspoon routes will be mounted. Changing this to "/jasmine" would allow you to browse to
--   # `http://localhost:3000/jasmine` to run your tests.
--   #config.mount_at = "/teaspoon"
-- 
--   # Specifies the root where Teaspoon will look for files. If you're testing an engine using a dummy application it can
--   # be useful to set this to your engines root (e.g. `Teaspoon::Engine.root`).
--   # Note: Defaults to `Rails.root` if nil.
--   #config.root = nil
-- 
--   # Paths that will be appended to the Rails assets paths
--   # Note: Relative to `config.root`.
--   #config.asset_paths = ["spec/javascripts", "spec/javascripts/stylesheets"]
-- 
--   # Fixtures are rendered through a controller, which allows using HAML, RABL/JBuilder, etc. Files in these paths will
--   # be rendered as fixtures.
--   #config.fixture_paths = ["spec/javascripts/fixtures"]
-- 
--   # SUITES
--   #
--   # You can modify the default suite configuration and create new suites here. Suites are isolated from one another.
--   #
--   # When defining a suite you can provide a name and a block. If the name is left blank, :default is assumed. You can
--   # omit various directives and the ones defined in the default suite will be used.
--   #
--   # To run a specific suite
--   # - in the browser: http://localhost/teaspoon/[suite_name]
--   # - with the rake task: rake teaspoon suite=[suite_name]
--   # - with the cli: teaspoon --suite=[suite_name]
     config.suite do |suite|
-- 
--     # Specify the framework you would like to use. This allows you to select versions, and will do some basic setup for
--     # you -- which you can override with the directives below. This should be specified first, as it can override other
--     # directives.
--     # Note: If no version is specified, the latest is assumed.
--     #
--     # Available: jasmine[1.3.1, 2.0.0], mocha[1.10.0, 1.17.1] qunit[1.12.0, 1.14.0]
       suite.use_framework :jasmine, "1.3.1"
-- 
--     # Specify a file matcher as a regular expression and all matching files will be loaded when the suite is run. These
--     # files need to be within an asset path. You can add asset paths using the `config.asset_paths`.
--     #suite.matcher = "{spec/javascripts,app/assets}/**/*_spec.{js,js.coffee,coffee}"
-- 
--     # This suites spec helper, which can require additional support files. This file is loaded before any of your test
--     # files are loaded.
--     #suite.helper = "spec_helper"
-- 
--     # The core Teaspoon javascripts. It's recommended to include only the base files here, as you can require support
--     # libraries from your spec helper.
--     # Note: For CoffeeScript files use `"teaspoon/jasmine"` etc.
--     #
--     # Available: teaspoon-jasmine, teaspoon-mocha, teaspoon-qunit
--     #suite.javascripts = ["jasmine/1.3.1", "teaspoon-jasmine"]
-- 
--     # You can include your own stylesheets if you want to change how Teaspoon looks.
--     # Note: Spec related CSS can and should be loaded using fixtures.
--     #suite.stylesheets = ["teaspoon"]
-- 
--     # Partial to be rendered in the head tag of the runner. You can use the provided ones or define your own by creating
--     # a `_boot.html.erb` in your fixtures path, and adjust the config to `"/boot"` for instance.
--     #
--     # Available: boot, boot_require_js
--     #suite.boot_partial = "boot"
-- 
--     # Partial to be rendered in the body tag of the runner. You can define your own to create a custom body structure.
--     #suite.body_partial = "body"
-- 
--     # Assets to be ignored when generating coverage reports. Accepts an array of filenames or regular expressions. The
--     # default excludes assets from vendor, gems and support libraries.<br/><br/>
--     #suite.no_coverage = [%r{/lib/ruby/gems/}, %r{/vendor/assets/}, %r{/support/}, %r{/(.+)_helper.}]
-- 
--     # Hooks allow you to use `Teaspoon.hook("fixtures")` before, after, or during your spec run. This will make a
--     # synchronous Ajax request to the server that will call all of the blocks you've defined for that hook name.
--     #suite.hook :fixtures, proc{ }
-- 
--   end
-- 
--   # Example suite. Since we're just filtering to files already within the root test/javascripts, these files will also
--   # be run in the default suite -- but can be focused into a more specific suite.
--   #config.suite :targeted do |suite|
--   #  suite.matcher = "test/javascripts/targeted/*_test.{js,js.coffee,coffee}"
--   #end
-- 
--   # CONSOLE RUNNER SPECIFIC
--   #
--   # These configuration directives are applicable only when running via the rake task or command line interface. These
--   # directives can be overridden using the command line interface arguments or with ENV variables when using the rake
--   # task.
--   #
--   # Command Line Interface:
--   # teaspoon --driver=phantomjs --server-port=31337 --fail-fast=true --format=junit --suite=my_suite /spec/file_spec.js
--   #
--   # Rake:
--   # teaspoon DRIVER=phantomjs SERVER_PORT=31337 FAIL_FAST=true FORMATTERS=junit suite=my_suite
-- 
--   # Specify which headless driver to use. Supports PhantomJS and Selenium Webdriver.
--   #
--   # Available: phantomjs, selenium
--   # PhantomJS: https://github.com/modeset/teaspoon/wiki/Using-PhantomJS
--   # Selenium Webdriver: https://github.com/modeset/teaspoon/wiki/Using-Selenium-WebDriver
--   #config.driver = "phantomjs"
-- 
--   # Specify additional options for the driver.
--   #
--   # PhantomJS: https://github.com/modeset/teaspoon/wiki/Using-PhantomJS
--   # Selenium Webdriver: https://github.com/modeset/teaspoon/wiki/Using-Selenium-WebDriver
--   #config.driver_options = nil
-- 
--   # Specify the timeout for the driver. Specs are expected to complete within this time frame or the run will be
--   # considered a failure. This is to avoid issues that can arise where tests stall.
--   #config.driver_timeout = 180
-- 
--   # Specify a server to use with Rack (e.g. thin, mongrel). If nil is provided Rack::Server is used.
--   #config.server = nil
-- 
--   # Specify a port to run on a specific port, otherwise Teaspoon will use a random available port.
--   #config.server_port = nil
-- 
--   # Timeout for starting the server in seconds. If your server is slow to start you may have to bump this, or you may
--   # want to lower this if you know it shouldn't take long to start.
--   #config.server_timeout = 20
-- 
--   # Force Teaspoon to fail immediately after a failing suite. Can be useful to make Teaspoon fail early if you have
--   # several suites, but in environments like CI this may not be desirable.
--   #config.fail_fast = true
-- 
--   # Specify the formatters to use when outputting the results.
--   # Note: Output files can be specified by using `"junit>/path/to/output.xml"`.
--   #
--   # Available: dot, documentation, clean, json, junit, pride, snowday, swayze_or_oprah, tap, tap_y, teamcity
--   #config.formatters = ["dot"]
-- 
--   # Specify if you want color output from the formatters.
--   #config.color = true
-- 
--   # Teaspoon pipes all console[log/debug/error] to $stdout. This is useful to catch places where you've forgotten to
--   # remove them, but in verbose applications this may not be desirable.
--   #config.suppress_log = false
-- 
--   # COVERAGE REPORTS / THRESHOLD ASSERTIONS
--   #
--   # Coverage reports requires Istanbul (https://github.com/gotwarlost/istanbul) to add instrumentation to your code and
--   # display coverage statistics.
--   #
--   # Coverage configurations are similar to suites. You can define several, and use different ones under different
--   # conditions.
--   #
--   # To run with a specific coverage configuration
--   # - with the rake task: rake teaspoon USE_COVERAGE=[coverage_name]
--   # - with the cli: teaspoon --coverage=[coverage_name]
-- 
--   # Specify that you always want a coverage configuration to be used.
--   #config.use_coverage = nil
-- 
     config.coverage do |coverage|
-- 
--     # Which coverage reports Instanbul should generate. Correlates directly to what Istanbul supports.
--     #
--     # Available: text-summary, text, html, lcov, lcovonly, cobertura, teamcity
--     #coverage.reports = ["text-summary", "html"]
-- 
--     # The path that the coverage should be written to - when there's an artifact to write to disk.
--     # Note: Relative to `config.root`.
--     #coverage.output_dir = "coverage"
-- 
--     # Various thresholds requirements can be defined, and those thresholds will be checked at the end of a run. If any
--     # aren't met the run will fail with a message. Thresholds can be defined as a percentage (0-100), or nil.
--     #coverage.statements = nil
--     #coverage.functions = nil
--     #coverage.branches = nil
--     #coverage.lines = nil
-- 
--   end
-- 
-- end

================================================================================
 ./spec/vcr_setup.rb
================================================================================
   require 'vcr'
-- 
   VCR.configure do |config|
     config.cassette_library_dir = 'vcr_cassettes'
     config.hook_into :webmock
     config.configure_rspec_metadata!
     config.allow_http_connections_when_no_cassette = true
-- end

