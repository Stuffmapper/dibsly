metric_fu shift the first line
================================================================================
 ./app/controllers/application_controller.rb
================================================================================
   class ApplicationController < ActionController::Base
--   # Prevent CSRF attacks by raising an exception.
--   # For APIs, you may want to use :null_session instead.
     protect_from_forgery with: :exception
     helper_method :current_user
-- 
     private
-- 
     def current_user
       @current_user ||= User.find(session[:user_id]) if session[:user_id]
--   end
-- 
-- end
-- 
--  
-- 

================================================================================
 ./app/controllers/dibs_controller.rb
================================================================================
   class DibsController < ApplicationController
-- 
   def create
       if current_user && params[:post_id]
-- 
         @post = Post.find(params[:post_id])
-- 
         if @post.available_to_dib?
            @post.create_new_dib(current_user, request.remote_ip)
            render json: '[]', status: :ok
--       end
-- 
--     else
         render json: '[]', status: :unprocessable_entity
--     end
--   end
-- 
     private
-- end

================================================================================
 ./app/controllers/messages_controller.rb
================================================================================
   class MessagesController < ApplicationController
     before_filter :verify_logged_in
-- 
     def index
       @messages = current_user.mailbox.inbox
       render json: @messages, status: :ok
--   end
-- 
     def show
       conversation = current_user.mailbox.conversations.where(:id => params[:id])[0]
       get_messages_from_conversation(conversation)
-- 
       render json: @messages, status: :ok
--   end
-- 
     def reply
        conversation = current_user.mailbox.conversations.where(:id => params[:id])[0]
        current_user.reply_to_conversation(conversation, message_params[:body])
        get_messages_from_conversation(conversation)
        render json: @messages, status: :ok
--      
--   end
-- 
--   # POST /messages
--   # POST /messages.json
     def create
       if message_params[:receiver_username].present? and message_params[:body].present?
         receipient = User.find_by_username(message_params[:receiver_username])
-- 
         subject, body = message_params[:subject], message_params[:body]
         current_user.send_message(receipient, body, subject)
-- 
         conversation = current_user.mailbox.conversations.first
-- 
         get_messages_from_conversation(conversation)
-- 
         render json: @messages, status: :ok
--     else
!!       render json: '[]',  status: :unprocessable_entity
--     end
--   end
-- 
     private
--     # Use callbacks to share common setup or constraints between actions.
-- 
       def verify_logged_in
         if not current_user
           render json: '[]', status: :unauthorized
--       end
--     end
-- 
--     # Never trust parameters from the scary internet, 
--     # only allow the white list through.
       def message_params
         params.require(:message).permit(:receiver_username, :body, :subject)
--     end
-- 
       def get_messages_from_conversation conversation
         receipts = conversation.receipts_for current_user
         @messages = receipts.collect{ |receipt| receipt.message }
--     end
-- end

================================================================================
 ./app/controllers/posts_controller.rb
================================================================================
   class PostsController < ApplicationController
--  
     before_action :set_post, only: [:show, :claim]
--         #this should be part of the model _ on save
-- 
--   # GET /posts
--   # GET /posts.json
-- 
     def index
       user_ip = request.location
--     
       if !user_ip.longitude == 0.0
!!       @map_center = {
--           'latitude'=> user_ip.latitude,
--           'longitude'=> user_ip.longitude 
--       }.to_json
-- 
--     else
         @map_center = {
--           'latitude'=> 47.6097,
--           'longitude'=> -122.3331
--       }.to_json
--     end
--   end
-- 
--   # POST /posts
--   # POST /posts.json
     def create
       if (current_user)
         cleaned_params = post_params.delete_if{
             |key, value| value == 'undefined'  
--       }
         @user = User.find( current_user.id )
         @post = Post.new(cleaned_params.merge(
--           :ip => request.remote_ip, 
--           :status => 'new', 
--           :creator_id => @user.id ))
-- 
         if @post.save
           @post.save
           render json: '[]', status: :ok
--       else
           render json: @post.errors, status: :unprocessable_entity
--       end
--     else
         render json: {error: 'not authorized '}, status: :unauthorized
--     end
--   end
-- 
--   # POST /posts/dib/1
--   # POST /posts/dib/1.json
     def dib
!!     if current_user && dib_params[:id] 
-- 
!!       @post = Post.find(dib_params[:id])
--     
!!       if @post.available_to_dib?
!!          @post.create_new_dib(current_user)
!!          add_dib(@post, request, current_user)
!!          render json: '[]', status: :ok 
--       end
--     else
!!       render json: '[]', status: :unprocessable_entity
--     end
--   end
-- 
--   # POST /posts/claim/1
--   # POST /posts/claim/1.json
-- 
     def geolocated 
       @posts = Post.where(:latitude => params[:swLat]..params[:neLat])
--                  .where(:longitude => params[:swLng]..params[:neLng])
       render json: @posts
--   end
-- 
--   # POST /posts/grid_mode.json
     def grid_mode
!!     session[:grid_mode] = params[:grid_mode]
!!     if (current_user)
!!       current_user.grid_mode = session[:grid_mode]
!!       current_user.save
--     end
!!     respond_to do |format|
!!         format.json {render json: '[]', status: :ok}
--     end
--   end
-- 
--   # GET /posts/search
     def search
!!     @posts = Post.where("title ILIKE ? 
--                  AND status = ? 
--                  AND (dibbed_until IS NULL 
--                    OR (dibbed_until IS NOT NULL 
--                      AND dibbed_until <= NOW()))", 
--                  "%#{params[:term]}%",
--                  'new').page(params[:page]).per(6)
!!     @term = params[:term]
!!     if (current_user)
!!       @post = Post.new(
--           :on_the_curb => 1,
--           :phone_number => current_user.phone_number)
!!       @message = Message.new()
--     else
!!       @user = User.new
--     end
!!     render action: 'index'
--   end
-- 
--   # GET /posts/my_stuff
     def my_stuff
       if (current_user)
         @posts = Post.where(:creator_id => current_user.id )
         render json: @posts
--     else
         render json: {message: 'User not logged in' }, status: :unauthorized
--     end
--   end
-- 
-- 
     private
--     # Use callbacks to share common setup or constraints between actions.
       def set_post
!!       @post = Post.find(params[:id])
--     end
-- 
--     # Never trust parameters from the scary internet, 
--     # only allow the white list through.
       def post_params
         params.permit(:image,:category, :latitude, :longitude)
--     end
-- 
-- 
-- end

================================================================================
 ./app/controllers/sessions_controller.rb
================================================================================
   class SessionsController < ApplicationController
     def create
-- 
       user = User.authenticate(params[:username], params[:password])
-- 
         if user
           session[:user_id] = user.id
           session[:latitude] = user.latitude
           session[:longitude] = user.longitude
           session[:zoom] = user.zoom
           session[:grid_mode] = user.grid_mode
           render json: {user:user.username}, status: :ok
--       else
           render json: '[]', status: :unprocessable_entity
--       end
--   end
-- 
     def destroy
       session[:user_id] = nil
       session[:latitude] = nil
       session[:longitude] = nil
       session[:zoom] = nil
       session[:grid_mode] = nil
       render json: '[]', status: :ok
--   end
-- 
     def check
       if current_user
-- 
         render json: {
--           message: 'User is logged in',
--           user: current_user.username },
--           status: :ok
--     else
         render json: {
--           message: 'User not logged in' },
--           status: :unauthorized
--     end
--   end
-- 
     private
--     # Never trust parameters from the scary internet, 
--     # only allow the white list through.
       def sessions_params
!!       params.permit(:username, :password)
--     end
-- end
-- 

================================================================================
 ./app/controllers/users_controller.rb
================================================================================
   class UsersController < ApplicationController
     before_action :set_user, only: [:show, :my_stuff]
-- 
--   # GET /users/1"111"
--   # GET /users/1.json
     def show
--   end
-- 
--   # POST /users
--   # POST /users.json
     def create
       @user = User.new(user_params.merge(
--             :ip => request.remote_ip,
--             :status => 'new'))
       if  @user.save
         session[:user_id] = @user.id
         render json: '[]', status: :ok
--     else
         render json: @user.errors, status: :unprocessable_entity
--     end
--   
--   end
-- 
--   # POST /users
--   # POST /users.json
     def my_stuff
!!     respond_to do |format|
!!       @user.valid?
!!       if @user.update(user_params)
!!         format.json {
!!             render json: '[]',
--             status: :ok
--         }
--       else
!!         format.json {
!!             render json: @user.errors,
--             status: :unprocessable_entity
--         }
--       end
--     end
--   end
-- 
-- 
-- 
--   # POST /users/presets.json
     def presets
!!     if !session[:latitude]
!!       session[:latitude] = 47.6612588;
--     end
!!     if !session[:longitude]
!!       session[:longitude] = -122.3078193;
--     end
!!     if !session[:zoom]
!!       session[:zoom] = 14;
--     end
!!     if !session[:grid_mode]
!!       session[:grid_mode] = true;
--     end
-- 
!!     respond_to do |format|
!!       format.json {render json: '{"latitude":'+session[:latitude].to_s+',
--         "longitude":'+session[:longitude].to_s+',
--         "zoom":'+session[:zoom].to_s+',
--         "grid_mode":'+session[:grid_mode].to_s+'}', status: :ok}
--     end
--   end
-- 
     private
--     # Use callbacks to share common setup or constraints between actions.
       def set_user
!!       @user = User.find(params[:id])
--     end
-- 
--     # Never trust parameters from the scary internet, 
--     # only allow the white list through.
       def user_params
         params.require(:user).permit(
--           :first_name,
--           :last_name,
--           :username,
--           :email,
--           :password,
--           :password_confirmation,
--           :address,
--           :latitude,
--           :longitude,
--           :on_the_curb,
--           :phone_number)
--     end
-- end

================================================================================
 ./app/helpers/application_helper.rb
================================================================================
   module ApplicationHelper
-- end

================================================================================
 ./app/helpers/dibs_controller_helper.rb
================================================================================
   module DibsControllerHelper
-- end

================================================================================
 ./app/helpers/dibs_helper.rb
================================================================================
   module DibsHelper
-- end

================================================================================
 ./app/helpers/feedbacks_helper.rb
================================================================================
   module FeedbacksHelper
-- end

================================================================================
 ./app/helpers/messages_helper.rb
================================================================================
   module MessagesHelper
-- end

================================================================================
 ./app/helpers/posts_helper.rb
================================================================================
   module PostsHelper
-- end

================================================================================
 ./app/helpers/sessions_helper.rb
================================================================================
   module SessionsHelper
-- end

================================================================================
 ./app/helpers/users_helper.rb
================================================================================
   module UsersHelper
-- end

================================================================================
 ./app/models/dib.rb
================================================================================
   class Dib < ActiveRecord::Base
     belongs_to :user, :class_name => User
     belongs_to :post, :class_name => Post
--   
     STATUSES = [STATUS_NEW = 'new', STATUS_DELETED = 'deleted', STATUS_FINISHED = 'finished']
-- 
--   # 43200 seconds = 12 hours
     @@timeSpan = 43200
     cattr_reader :timeSpan
--   
     validates_presence_of :creator_id
     validates_presence_of :post_id
     validates :status, inclusion: {in: STATUSES}
-- 
-- 
--   # to make sure we don't expose it
     def ip
       ''
--   end
-- end

================================================================================
 ./app/models/message.rb
================================================================================
   class Message < ActiveRecord::Base
     belongs_to :user, :class_name => User, :foreign_key => :sender_id
     belongs_to :user, :class_name => User, :foreign_key => :receiver_id
     attr_readonly :creator_id
-- 
     STATUSES = [STATUS_NEW = 'new', STATUS_DELETED = 'deleted', STATUS_READ = 'read']
-- 
     default_scope { order('created_at DESC') }
-- 
     validates_presence_of :sender_id
     validates_presence_of :receiver_id
     validates_presence_of :content
     validates :status, inclusion: {in: STATUSES}
-- 
     def send_notification(subject, text_content, html_content)
!!     @receiver = User.find(self.receiver_id)
-- 
!!     require 'mandrill'
!!     mandrill = Mandrill::API.new '-q-BEin2lOraKbC6UOJsPw'
!!     message = {"from_name"=>"Stuffmapper",
--                "from_email"=>"contactl@stuffmapper.com",
--                "subject"=>subject,
--                "to"=> [{"email"=>@receiver.email}],
--                "text"=>text_content,
--                "html"=>html_content,
--     }
-- 
!!     async = false
!!     result = mandrill.messages.send message, async, "Main Pool"
!!     logger.debug "Mandrill result: #{result}"
-- 
--   rescue Mandrill::Error => e
!!     logger.debug "Mandrill error occurred: #{e.class} - #{e.message}"
--   end
-- 
-- 
--   # to make sure we don't expose it
     def ip
!!     ''
--   end
-- end

================================================================================
 ./app/models/post.rb
================================================================================
   class Post < ActiveRecord::Base
--   
     belongs_to :user, :class_name => User
     has_many :dibs, :class_name => Dib, :foreign_key => :post_id
     has_attached_file :image,
--     :styles => { :medium => "300x300>" }, :default_url => "/images/:style/missing.png",
--     :storage => :s3,
--     :s3_credentials => "#{Rails.root}/config/aws.yml"
-- 
     validates_attachment_content_type :image, :content_type => /\Aimage\/.*\Z/
     attr_readonly :creator_id
     STATUSES = [STATUS_NEW = 'new', STATUS_DELETED = 'deleted', STATUS_CLAIMED = 'claimed', STATUS_DIBBED = 'dibbed']
--   
     default_scope { order('created_at DESC') }
-- 
     validates_attachment_presence :image
     validates_presence_of :creator_id
     validates_presence_of :longitude, :latitude
     validates :status, inclusion: {in: STATUSES}
     after_validation :update_image
-- 
     def send_message_to_creator (dibber, body, subject)
       dibber.send_message( User.find(self.creator_id), body,subject) 
--   end
-- 
     def create_new_dib (dibber, request_ip='')
       self.dibbed_until = Time.now + Dib.timeSpan
       self.status == 'dibbed'
       self.dibber_id = dibber.id
       self.save
       dib = self.dibs.build
       dib.ip = request_ip
       dib.valid_until = self.dibbed_until
       dib.status = 'new'
       dib.creator_id = dibber.id 
       dib.save
       send_message_to_creator(dibber, (dibber.username + " Has dibbed your stuff" ), " respond_to this message to get in contact")
--   end
-- 
     def available_to_dib?
       self.status == 'new' && self.dibbed_until == nil || self.dibbed_until <= Time.now
--   end
-- 
-- 
-- 
     def coords
!!     {'lat'=> self.latitude, 'lng'=> self.longitude }
--   end
-- 
-- 
-- 
-- 
     def ip
       ''
--   end
-- 
     protected
-- 
     def update_image
-- 
       self.image_url = self.image.url(:medium)
--   end
-- 
-- end

================================================================================
 ./app/models/user.rb
================================================================================
   class User < ActiveRecord::Base
     has_many :posts, :class_name => Post, :foreign_key => :creator_id
     has_many :dibs, :class_name => Dib, :foreign_key => :creator_id
     has_many :messages, :class_name => Message, :foreign_key => :sender_id
     STATUSES = [STATUS_NEW = 'new', STATUS_DELETED = 'deleted']
--   
--   # attr_accessor allows you to use the password attribute locally, but will not persist it to the database
     attr_accessor :password
     before_save :encrypt_password
--   
     validates_presence_of :first_name
     validates_presence_of :last_name
     validates_uniqueness_of :username
     validates_confirmation_of :password
     validates_presence_of :password, :on => :create
     validates_format_of :email, :with => /\A[^@]+@([^@\.]+\.)+[^@\.]+\z/
     validates :status, inclusion: {in: STATUSES}
     acts_as_messageable
-- 
     def save(*args)
       super
--   rescue ActiveRecord::RecordNotUnique => error
       errors[:base] << "Duplicate username or email"
       false
--   end
-- 
     def self.authenticate(username, password)
       user = find_by_username(username)
       if user && user.status == STATUS_NEW && user.password_hash == BCrypt::Engine.hash_secret(password, user.password_salt)
         user
--     else
--       nil
--     end
--   end
--   
     def encrypt_password
       if password.present?
         self.password_salt = BCrypt::Engine.generate_salt
         self.password_hash = BCrypt::Engine.hash_secret(password, password_salt)
--     end
--   end
-- 
     def mailboxer_email(object)
!!     self.email
--   end
-- 
--   # to make sure we don't expose it
     def ip
       ''
--   end
-- end

================================================================================
 ./app/serializers/post_serializer.rb
================================================================================
   class PostSerializer < ActiveModel::Serializer
     attributes :id, :latitude, :longitude, :image_url, :coords, :image_url
-- 
     def coords
       {'latitude'=> self.latitude, 'longitude'=> self.longitude }
--   end
-- end

